[["środowisko-i-konfiguracja.html", "Praca z oprogramowaniem dla Compute Module 4 (Raspberry Pi) Rozdział 1 Środowisko i konfiguracja 1.1 Obrazy systemu operacyjnego 1.2 Instalacja Visual Studio Code 1.3 C/C++ z CMake dla ARM", " Praca z oprogramowaniem dla Compute Module 4 (Raspberry Pi) Patryk Tomaszewski 2023-05-07 Rozdział 1 Środowisko i konfiguracja W zależności od platformy sprzętowej, używanych języków programowania oraz specyfiki projektu, debugowanie pisanego oprogramowania różni się, ale zasadniczo zawsze sprowadza do identycznych możliwości (np. kroczenie po kodzie, czy przeglądanie wartości zmiennych). W tej notce opiszę jak można skonfigurować VSCode do debugowania programu c++ na platformie CM4 ze swojego sprzętu komputerowego po sieci. Raspberry Pi CM4 to zminiaturyzowana wersja minikomputera Raspberry Pi 4B. Kompatybilna z gniazdami płytki CM4IO Board. Płytka oparta została na procesorze Broadcom BCM2711 z 4 GB pamięci RAM oraz 32 GB pamięci eMMC. Moduł wyposażony w komunikację bezprzewodową WiFi / Bluetooth. Dlaczego to jest potrzebne? Korzystanie z takich interfejsów jak I2C, SPI, UART, których na swoim komputerze przeważnie nie posiadamy, czy wykorzystanie możliwości GPIO może sprawiać problemy, które rozwiązuje się dopiero po zrozumieniu problemu. Natomiast zrozumieć problem w kodzie (szczególnie swoim) jest możliwe w momencie, gdy widzimy co się dzieje, a w tym szczególnie pomocny jest debugger. Z drugiej strony dlaczego nie pisać programu, kompilować go i uruchamiać w IDE na RPI? Kompilacja na Raspberry (i innych platformach Embedded) większych projektów jest czasochłonna (mozolne, żmudne i uciążliwe wręcz). Kompilacja na wielordzeniowym laptopie czy komputerze programów na platformę ARM za pomocą cross-kompilatora wypada znacznie lepiej. Ze względu na różnorodność systemów operacyjnych i co ważniejsze obecności Windows 7 na świecie (brak już wsparcia Microsoft’u) używać będę VBox’a z obrazem systemu na architekturę amd64 (obecnym na CM4 tylko w architekturze ARM). Wspomnieć mogę jeszcze o WSL obecnym na Win10, czy Dockerze, które mogłyby “trochę” zoptymalizować pracę, ale opis tutaj będzie nieco oldschool’owy. 1.1 Obrazy systemu operacyjnego Na platformie CM4: Raspberry Pi OS Release date: September 22nd 2022 Kernel version: 5.10 Debian version: 10 (buster) Link do obrazów na VBox’a. Można również pobrać obraz Raspberry Pi OS i uruchomić go na Virtual Box’ie (szczegółowy opis by Emmet, ang.). 1.2 Instalacja Visual Studio Code VSCode (Visual Studio Code z Microsoft’u) jest obecny na platformach Windows, Linux i macOS. Od lipca 2016 roku Marketplace (oferujący rozszerzenia) urósł pokaźnie, a sama instalacja rozszerzenia sprowadza się do kliknięcia “Instaluj” (w przypadku dobrze zarządzanych projektów). Instalacja VSCode w VBox’ie, ale najpierw, aby uniknąć przypadkowych błędów, aktualizacja indeksu APT: sudo apt-get update Pobieranie curl (jeśli jescze go nie mamy): sudo apt install gnupg2 software-properties-common apt-transport-https curl Pobieranie klucza i dodawanie do zaufanych w APT: curl -sSL https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - Dodanie repozytorium VSCode’a: sudo add-apt-repository &quot;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main&quot; Aktualizacja indeksu (wyżej dodane zostało repo, dlatego potrzebna jest ponowna aktualizacja): sudo apt update W końcu instalacja Visual Studio Code: sudo apt install code W przypadku, gdy jedynym użytkownikiem w systemie jest root albo po prostu chcemy uruchomić IDE z poziomu sudoers: code --no-sandbox --user-data-dir /home/user/ 1.3 C/C++ z CMake dla ARM CMake z pomocą plików CMakeLists.txt służy do zarządzania procesem kompilacji programu, a właściwie to składa konfigurację, czyli pliki z regułami kompilacji dla wybieranego przez użytkownika środowiska, sam nie kompiluje programu. Jego główną cechą jest niezależność od używanego kompilatora oraz platformy sprzętowej. Instalacja CMake: sudo apt-get update sudo apt install cmake Zanim uruchomimy VSCode najpierw zainstalujmy cross compiler (dla ARM): sudo apt update sudo apt-get install build-essential binutils-arm-linux-gnueabihf binutils-arm-linux-gnueabihf-dbg Dodatkowo do pracy z Boost czy Qt potrzebujemy bibliotek na docelową platformę, ale najpierw dodajemy do indeksu APT architekturę ARM: sudo dpkg --add-architecture armhf Poniższe polecenia mogą się przydać: apt-get install libbsd-dev:armhf apt-get install libssl-dev:armhf apt-get install openssl:armhf Instalacja bibliotek boost dla ARM: apt-get install libboost-dev:armhf apt-get install libboost-system1.67-dev:armhf apt-get install libboost-thread1.67-dev:armhf apt-get install libboost-filesystem1.67-dev:armhf Instalacja bibliotek Qt5 dla ARM: apt-get install qtdeclarative5-dev:armhf apt-get install libqt5charts5-dev:armhf Do pracy w VSCode z c++ zainstalujmy kilka rozszerzeń: Rozszerzenie C/C++ (by Microsoft) Rozszerzenie CMake (by twxs) Rozszerzenie CMake Tools (by Microsoft) Rozszerzenie Native Debug (by WebFreak) Poniżej screeny: Na początek utwórzmy nowy katalog: mkdir cmakeQuickStart cd cmakeQuickStart code . Zobaczmy szablon jaki produkuje rozszerzenie CMake: Wybierzmy od razu cross compiler: Wskazujemy, że chcemy konfigurację do kompilacji aplikacji: Wpisujemy nazwę projektu: Pod spodem powstało kilka plików (wykonane zostało następujące polecenie cmake): /usr/bin/cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/arm-linux-gnueabihf-gcc -DCMAKE_CXX_COMPILER:FILEPATH=/usr/bin/arm-linux-gnueabihf-g++ -S/home/user/cmakeQuickStart -B/home/user/cmakeQuickStart/build -G &quot;Unix Makefiles&quot; W katalogu powstał plik CMakeLists.txt: cmake_minimum_required(VERSION 3.0.0) project(quickstart VERSION 0.1.0) include(CTest) enable_testing() add_executable(quickstart main.cpp) set(CPACK_PROJECT_NAME ${PROJECT_NAME}) set(CPACK_PROJECT_VERSION ${PROJECT_VERSION}) include(CPack) 1.3.1 O plikach CMakeLists.txt W zależności od używanych funkcji i ich pojawienia się na przestrzeni czasu, minimalna wymagana wersja cmake: cmake_minimum_required(VERSION 3.0.0) Nazwa opisywanego projektu: project(quickstart VERSION 0.1.0) Dołączenie modułu CTest: include(CTest) załączenie testów (uwaga: enable_testing jest wołany w include(CTest)) : enable_testing() Wskazanie z jakich źródeł ma budować aplikację (w dalszej części opisze jak wyszukiwać źródła): add_executable(quickstart main.cpp) Pakowanie oprogramowania (zautomatyzuje utworzenie zip, instalatora, ale sam tego nie zrobi): set(CPACK_PROJECT_NAME ${PROJECT_NAME}) set(CPACK_PROJECT_VERSION ${PROJECT_VERSION}) include(CPack) 1.3.1.1 Bardziej rozbudowany projekt Cmake może służyć do zarządzania wieloma projektami. Kompilacja odbywa się kaskadowo w zależności jak sporządzimy pliki CMakeLists.txt. Poniżej opiszę sytuację podobną do tej z Microsoft Visual Studio, czyli rozwiązania i projekty oraz przedstawię kilka informacji o języku cmake. Wypisywanie informacji na ekranie oraz instrukcja warunkowa: message(&quot;Informacja wypisywana podczas użycia cmake&quot;) if(&quot;${CMAKE_BUILD_TYPE}&quot; STREQUAL &quot;Release&quot;) message(&quot;Konfiguracja kompilacji Release&quot;) else() message(&quot;Konfiguracja kompilacji prawdopodobnie Debug&quot;) endif() Dodanie flagi do kompilacji plików źródłowych (wszystkich na raz lub pojedynczo): add_definitions(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON) add_definitions( -DUNICODE -D__USE_LARGEFILE64=1 -DNOMINMAX=1 -DBOOST_ALL_NO_LIB ) Użyte flagi oznaczają: CMAKE_EXPORT_COMPILE_COMMANDS - generuje plik compile_commands.json zawierający wszystkie wywołania kompilatora (nie linkera), UNICODE - używana strona kodowa w projekcie, __USE_LARGEFILE64 - użycie rozszerzonych metod dostępu do plików (większych niż ~2GB, fopen staje się fopen64 itd.), NOMINMAX - wykluczenie wbudowanych definicji dla min i max (które będą problemem podczas używania std::min, std::max), BOOST_ALL_NO_LIB - gdy z góry wiemy, które biblioteki boost mają zostać dołączone. Ustawianie standardu języka c/c++: set(CMAKE_C_STANDARD 11) set(CMAKE_C_STANDARD_REQUIRED True) set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED True) Ustawienie katalogu instalacji: set(CMAKE_INSTALL_PREFIX &quot;${CMAKE_CURRENT_SOURCE_DIR}/bin&quot;) Zmienna CMAKE_CURRENT_SOURCE_DIR wskazuje na katalog główny projektu. Ustawienie dodatkowych flag kompilatora dla wersji Debug: set(CMAKE_CXX_FLAGS_DEBUG &quot;${CMAKE_CXX_FLAGS_DEBUG} -g&quot;) Ustawienie dodatkowych flag kompilatora dla wersji Release: set(CMAKE_CXX_FLAGS_RELEASE &quot;${CMAKE_CXX_FLAGS_RELEASE} -DNDEBUG&quot;) Wskazywanie dodatkowych katalogów nagłówków: include_directories(common googletest-1.12.1/googletest/include) Powyższe katalogi wskazują na projekt (w tym przypadku bibliotekę statyczną) oraz umieszczony w rozwiązaniu googletest. Wskazywanie katalogów z dodatkowymi bibliotekami: link_directories(googletest-1.12.1/buildARM/${CMAKE_BUILD_TYPE}/lib) GoogleTest skompilowany na ARM w głównym folderze projektu, gdzie: buildARM - wybrana nazwa folderu dla kompilacji na ARM, CMAKE_BUILD_TYPE - to wersja kompilacji (Debug, Release). Dodawanie katalogów projektów: add_subdirectory(common) add_subdirectory(aplikacja) add_subdirectory(unittests) gdzie: common - będzie biblioteką wspólną dla projektu, aplikacja - wynikiem kompilacji jest plik wykonywalny, unittests - testy powyższych projektów w GoogleTest. Dołączanie bibliotek dla całego rozwiązania: link_libraries(glibc) link_libraries(bsd) gdzie: glibc - podstawowe biblioteki podczas pisania na Linuksie (np. open, read, write, malloc, printf, getaddrinfo, dlopen, pthread_create, crypt, login, exit), bsd - zawiera funkcje wypracowane w systemach BSD, a których brak w innych systemach doskwiera. Rekursywne wyszukanie plików źródłowych: file(GLOB_RECURSE common_CPP &quot;*.cpp&quot; &quot;*.c&quot;) file(GLOB_RECURSE common_HPP &quot;*.hpp&quot; &quot;*.h&quot;) Polecenie file przyjmuje: GLOB &lt; zmienna wyjściowa &gt; &lt; wyrażenie regularne &gt; - wyszukiwanie plików w bieżącym katalogu GLOB_RECURSE &lt; zmienna wyjściowa &gt; &lt; wyrażenie regularne &gt; - wyszukiwanie plików w całym katalogu (podkatalogach, itd.) READ &lt; nazwa pliku &gt; &lt; zmienna wyjściowa &gt; - wczytanie pliku tekstowego do zmiennej WRITE &lt; nazwa pliku &gt; &lt; zawartość &gt; - zapisanie zawartości zmiennej do pliku APPEND &lt; nazwa pliku &gt; &lt; zawartość &gt; - dopisanie zawartości zmiennej do pliku MAKE_DIRECTORY &lt; folder &gt; - utworzenie katalogu REMOVE &lt; plik(i) &gt; - usunięcie pliku REMOVE_RECURSE &lt; plik(i) &gt; - usunięcie pliku lub katalogu RENAME &lt; ścieżka do pliku &gt; &lt; ścieżka wyjściowa &gt; - przeniesienie pliku lub katalogu COPY &lt; plik(i) &gt; &lt; ścieżka wyjściowa &gt; - kopiowanie pliku lub katalogu Dołączenie podstawowych bibliotek z Boost: find_package(Boost COMPONENTS system thread container bind filesystem REQUIRED) Wskazanie źródeł, z których będzie budowana biblioteka: add_library(common ${common_HPP} ${common_CPP}) Wskazanie źródeł, z których będzie budowana aplikacja: add_executable(aplikacja ${aplikacja_CPP}) Dodawanie używanych bibliotek aplikacji dla linkera: set(LIBS_TO_LINK -lm -lpthread -ldl -lrt -lz -lstdc++fs -lbsd -lzmq -lbson-1.0 -lcrypto -lzstd -lfmtd -lspdlogd) target_link_libraries(aplikacja PRIVATE common ${Boost_LIBRARIES} ${LIBS_TO_LINK}) Dodawanie ścieżki do plików nagłówkowych: target_include_directories(aplikacja PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}) gdzie: PRIVATE - określa zasięg widoczności tylko do aktualnego projektu, CMAKE_CURRENT_SOURCE_DIR - ścieżka do aktualnego projektu. Utworzenie folderu wyjściowego przed kompilacją aplikacji: add_custom_command( TARGET aplikacja PRE_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory &quot;${CMAKE_SOURCE_DIR}/${CMAKE_BUILD_TYPE}${RELTYP}&quot; ) gdzie: TARGET - wskazanie celu, PRE_BUILD - wykonanie przed budowaniem, COMMAND - polecenie, CMAKE_COMMAND - pełna ścieżka do CMake, cmake -E make_directory - utworzenie folderu za pomocą CMake. Skopiowanie pliku wyjściowego (aplikacji) do innego folderu: add_custom_command( TARGET aplikacja POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy $&lt;TARGET_FILE:aplikacja&gt; ${CMAKE_SOURCE_DIR}/${CMAKE_BUILD_TYPE}${RELTYP}/$&lt;TARGET_FILE_NAME:aplikacja&gt; gdzie: POST_BUILD - wykonanie po budowaniu, cmake -E copy - kopiowanie pliku, CMAKE_SOURCE_DIR - ścieżka rozwiązania (nie projektu), CMAKE_BUILD_TYPE - Debug, Release, RELTYP - definicja zmiennej, w tym wypadku określam inny folder do budowania na ARM, $&lt;TARGET_FILE:aplikacja&gt; - nazwa pliku wykonywalnego, biblioteki (z rozszerzeniem), $&lt;TARGET_FILE_NAME:aplikacja&gt; - ścieżka pliku wykonywalnego, biblioteki. Kompilacja rozwiązania dla ARM: cmake -S ../../ -DCMAKE_BUILD_TYPE=Release -D CMAKE_C_COMPILER=arm-linux-gnueabihf-gcc -D CMAKE_CXX_COMPILER=arm-linux-gnueabihf-g++ -D RELTYP=&quot;ARM&quot; Argument -S ../../ oznacza podanie ścieżki, gdzie znajduje się główny CMakeLists.txt projektu. Definicje CMAKE_C_COMPILER, CMAKE_CXX_COMPILER wskazują kompilatory, natomiast RELTYP nie jest z niczym specjalnym związany. Na potrzeby swoich projektów można definiować własne wartości. Całość wyglądać będzie następująco: # Główny CMakeLists.txt (Rozwiązania) project(major_solution VERSION 0.1.0) add_definitions(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON) add_definitions( -DUNICODE -D__USE_LARGEFILE64=1 -DNOMINMAX=1 -DBOOST_ALL_NO_LIB ) set(CMAKE_C_STANDARD 11) set(CMAKE_C_STANDARD_REQUIRED True) set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_INSTALL_PREFIX &quot;${CMAKE_CURRENT_SOURCE_DIR}/bin&quot;) set(CMAKE_CXX_FLAGS_DEBUG &quot;${CMAKE_CXX_FLAGS_DEBUG} -g&quot;) set(CMAKE_CXX_FLAGS_RELEASE &quot;${CMAKE_CXX_FLAGS_RELEASE} -DNDEBUG&quot;) include_directories(common fmt-9.1.0/include flatbuffers-1.12.0/include spdlog-1.10.0/include nlohmann-3.11.2 zstd-1.5.2/lib googletest-1.12.1/googletest/include) if(&quot;${RELTYP}&quot; STREQUAL &quot;ARM&quot;) message(&quot;Arm...&quot;) link_directories(fmt-9.1.0/buildARM/${CMAKE_BUILD_TYPE} flatbuffers-1.12.0/buildARM/${CMAKE_BUILD_TYPE} spdlog-1.10.0/buildARM/${CMAKE_BUILD_TYPE} zstd-1.5.2/buildARM/${CMAKE_BUILD_TYPE}/lib googletest-1.12.1/buildARM/${CMAKE_BUILD_TYPE}/lib) else() message(&quot;Normal...&quot;) link_directories(fmt-9.1.0/build/${CMAKE_BUILD_TYPE} flatbuffers-1.12.0/build/${CMAKE_BUILD_TYPE} spdlog-1.10.0/build/${CMAKE_BUILD_TYPE} zstd-1.5.2/build/${CMAKE_BUILD_TYPE}/lib googletest-1.12.1/build/${CMAKE_BUILD_TYPE}/lib) endif() add_subdirectory(common) add_subdirectory(aplikacja) add_subdirectory(unittests) link_libraries(glibc) link_libraries(bsd) Biblioteka common: file(GLOB_RECURSE common_CPP &quot;*.cpp&quot; &quot;*.c&quot;) file(GLOB_RECURSE common_HPP &quot;*.hpp&quot; &quot;*.h&quot;) add_library(common ${common_HPP} ${common_CPP}) target_include_directories(common PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}) Projekt aplikacji: file(GLOB_RECURSE APLIKACJA_SOURCES &quot;*.cpp&quot; &quot;*.hpp&quot; &quot;.c&quot; &quot;.h&quot;) set(PROJ_NAME aplikacja) project(${PROJ_NAME}) set(Boost_USE_STATIC_LIBS OFF) set(Boost_USE_MULTITHREADED ON) set(Boost_USE_STATIC_RUNTIME OFF) if (CMAKE_BUILD_TYPE STREQUAL &quot;Debug&quot;) set(LIBS_TO_LINK -lm -lpthread -ldl -lrt -lz -lstdc++fs -lbsd -lzmq -lbson-1.0 -lcrypto -lzstd -lfmtd -lspdlogd) else () set(LIBS_TO_LINK -lm -lpthread -ldl -lrt -lz -lstdc++fs -lbsd -lzmq -lbson-1.0 -lcrypto -lzstd -lfmt -lspdlog) endif () find_package(Boost COMPONENTS system thread container bind filesystem REQUIRED) add_executable(${PROJ_NAME} ${APLIKACJA_SOURCES}) target_link_libraries(${PROJ_NAME} PRIVATE common ${Boost_LIBRARIES} ${LIBS_TO_LINK}) target_include_directories(${PROJ_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}) add_custom_command( TARGET ${PROJ_NAME} PRE_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory &quot;${CMAKE_SOURCE_DIR}/${CMAKE_BUILD_TYPE}${RELTYP}&quot; ) add_custom_command( TARGET ${PROJ_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy $&lt;TARGET_FILE:${PROJ_NAME}&gt; ${CMAKE_SOURCE_DIR}/${CMAKE_BUILD_TYPE}${RELTYP}/$&lt;TARGET_FILE_NAME:${PROJ_NAME}&gt; ) 1.3.2 Warto napisać skrypt dla kompilacji Kompilacja na urządzeniu: #!/usr/bin/env bash CONF=&quot;Debug&quot; if [ &quot;$#&quot; -gt 0 ]; then CONF=$1 fi mkdir -p &quot;build/${CONF}&quot; cd &quot;build/${CONF}&quot; cmake -G &quot;CodeLite - Unix Makefiles&quot; -S ../../ -DCMAKE_BUILD_TYPE=$CONF -DRELTYP=&quot;&quot; make Kompilacja skrośna (cross compile) na ARM: #!/usr/bin/env bash CONF=&quot;Release&quot; if [ &quot;$#&quot; -gt 0 ]; then CONF=$1 fi mkdir -p &quot;buildARM/${CONF}&quot; cd &quot;buildARM/${CONF}&quot; cmake -S ../../ -DCMAKE_BUILD_TYPE=$CONF -D CMAKE_C_COMPILER=arm-linux-gnueabihf-gcc -D CMAKE_CXX_COMPILER=arm-linux-gnueabihf-g++ -DRELTYP=&quot;ARM&quot; make "],["debugowanie-zdalne-z-gdb-the-gnu-project-debugger.html", "Rozdział 2 Debugowanie zdalne z GDB (The GNU Project Debugger) 2.1 Instalacja 2.2 Konfiguracja 2.3 Problemy", " Rozdział 2 Debugowanie zdalne z GDB (The GNU Project Debugger) GNU Debugger (GDB) – debugger będący częścią projektu GNU, napisany w 1988 r. przez Richarda Stallmana. Program obsługuje wiele architektur komputera i jest dostępny dla wielu systemów operacyjnych. Potrafi otworzyć bardzo dużo formatów binarnych, zawdzięcza to BFD. Zazwyczaj zamiast pełnej nazwy używa się akronimu GDB. GNU Debugger jest dostępny na warunkach licencji GNU General Public License. 2.1 Instalacja Instalacja gdb-multiarch: sudo apt-get update sudo apt install gdb-multiarch Instalacja rozszerzenia Native Debug (by WebFreak): 2.2 Konfiguracja W zakładce debugowania klikamy na “create a launch.json file”, następnie wybieramy GDB: Otwieramy plik: .vscode\\settings.json Zawartość przedstawia się następująco: { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Debug&quot;, &quot;type&quot;: &quot;gdb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;target&quot;: &quot;./bin/executable&quot;, &quot;cwd&quot;: &quot;${workspaceRoot}&quot;, &quot;valuesFormatting&quot;: &quot;parseText&quot; } ] } Definicje możemy prześledzić tutaj. Parametry oznaczają: name - nazwa konfiguracji, type - typ konfiguracji (ustawienia gdb), request - polecenie uruchomienia, target - cel uruchomienia, cwd - folder uruchomienia, valuesFormatting - formatowanie danych (zmienne w pamięci dla debugera, itd.). Do zdalnego debugowania plik należy zmodyfikować: { // Użyj funkcji IntelliSense, aby uzyskać informacje o możliwych atrybutach. // Najedź kursorem, aby wyświetlić opisy istniejących atrybutów. // Aby uzyskać więcej informacji, odwiedź stronę: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Attach to gdbserver&quot;, &quot;type&quot;: &quot;gdb&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;executable&quot;: &quot;./DebugARM/aplikacja&quot;, &quot;target&quot;: &quot;192.168.1.123:9999&quot;, &quot;remote&quot;: true, &quot;cwd&quot;: &quot;${workspaceRoot}&quot;, &quot;gdbpath&quot;: &quot;gdb-multiarch&quot;, &quot;debugger_args&quot; : [&quot;-iex=set solib-search-path = \\&quot;./DebugARM/\\&quot;&quot;], &quot;valuesFormatting&quot;: &quot;parseText&quot; } ] } Jak konkretnie wykorzystywane są powyższe parametry możemy zobaczyć tutaj. Oznaczają mniej więcej: request - w tym wypadku informacja dla VSCode o zdalnym debugowaniu, executable - zawartość target z poprzedniej konfiguracji, target - tym razem celem jest Raspberry Pi pod adresem 192.168.1.123, remote - informacja dla Native Debug o zdalnym debugowaniu, gdbpath - plik wykonywalny gdb, debugger_args - argumenty przekazywane do gdb. Uruchomienie na CM4: gdbserver localhost:9999 ./aplikacja 2.3 Problemy Podczas uruchomienia aplikacji może okazać się, że nie znajduje biblioteki (w tym przypadku libcommon.so) będącej w bieżącym folderze. Aby uniknąć każdorazowego kopiowania biblioteki do np. /usr/lib można uruchamiać program w następujący sposób: LD_LIBRARY_PATH=/home/user/cmakeQuickStart gdbserver localhost:9999 ./aplikacja "],["uruchamianie-aplikacji-przy-starcie.html", "Rozdział 3 Uruchamianie aplikacji przy starcie 3.1 Definiowanie usługi 3.2 Podstawowe polecenia systemctl", " Rozdział 3 Uruchamianie aplikacji przy starcie Preferowaną i ujednoliconą metodą na wykonywanie programów przy uruchomieniu w systemach linuksowych jest systemd (menadżer systemu i usług). Do kontroli usług służy systemctl. 3.1 Definiowanie usługi Zdefiniowanie serwisu wiąże się z utworzeniem pliku w /etc/systemd/system/: sudo nano /etc/systemd/system/aplikacja.service Zgodnie z przyjętym formatem rozszerzenie pliku to .service. Zawartość pliku może wyglądać następująco: [Unit] Description=Aplikacja by Patryk Tomaszewski (Asura Codes) After=network.target [Service] Type=simple User=user Restart=always RestartSec=5 Environment=LD_LIBRARY_PATH=/home/user/cmakeQuickStart WorkingDirectory=/home/user/cmakeQuickStart/ ExecStart=/home/user/cmakeQuickStart/aplikacja [Install] WantedBy=multi-user.target gdzie: Description - nazwa usługi, After - uruchomienie ma następować po uruchomieniu sieci, Type - typ usługi (simple, forking, oneshot, dbus, notify oraz idle dla Debiana), User - uruchomienie procesu jako użytkownik user, Restart - w przypadku procesu, który ma być uruchamiany co jakiś czas (lub błędu programu…), ponowne uruchomienie usługi, RestartSec - wskazanie po jakim czasie w sekundach ma uruchomić aplikacje (po jej zakończeniu), Environment - zmienne środowiskowe, WorkingDirectory - katalog roboczy / aktualny katalog, ExecStart - ścieżka do aplikacji (to nie jest polecenie jak w linii poleceń), WantedBy - utworzenie przed multi-user.target (poziom ładowania 2). 3.2 Podstawowe polecenia systemctl Do uruchomienia nowo dodanej usługi potrzebne jest przeładowanie wszystkich usług i odtworzenie całego drzewa zależności do czego służy: sudo systemctl daemon-reload Uruchomienie aplikacji: sudo systemctl start aplikacja Sprawdzenie statusu i logów z aplikacji: sudo systemctl status aplikacja sudo systemctl status -n 80 aplikacja Zatrzymanie aplikacji: sudo systemctl stop aplikacja W przypadku braku możliwości zatrzymania w powyższy sposób można wymusić zamknięcie: sudo systemctl kill aplikacja Zamiast używać dwóch poleceń systemctl stop oraz systemctl start można zrobić restart: sudo systemctl try-restart aplikacja sudo systemctl restart aplikacja "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
